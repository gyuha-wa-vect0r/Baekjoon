4 = 1+1+1+1 = 2+1+1, 1+2+1, 1+1+2 = 2+2 = 1+3, 3+1 -> 4가지!
처럼 입력받은 수 n을 1, 2, 3의 합으로 나타내는 경우의 수를 구하라...
먼저 3으로 빼고 그 수로 더이상 못 빼면 2로 빼고 그거마저 안된다면 1로 빼면 되지 않을까...
ex) 7 : 7-3=4, 4-3=1, 1-1=0 -> 3+3+1 / 7-2=5, 5-2=3, 3-2=1, 1-1=0 -> 2+2+2+1 / 
        7-1=6 ... 1-1=0 -> 1+1+1+1+1+1+1
        
아 아니다
먼저 3으로 시작하는 것으로 빼면 3+3+1으로 표현이 되는데, 여기서 3을 2로 시작하는 것으로 빼면 2가지다
하나의 3만 2와 1로 쪼갤지(2+1+3+1) 아니면 모든 3을 2와 1로 쪼갤건지(2+1+2+1+1)... -> 3을 쪼개는건 여기서 끝
그리고 여기서 (2+1+3+1)
331
2131 
11131 
111211
1111111

아 아니다
반대로 생각해보자...
7은 1111111이고 이것 내에서 더한다고 생각하보자... 3까지니까 1 세개 더하는게 최대 덧셈이다.
두개 더할때 모든 경우 211111, 22111, 2221
여기서 2와 1 하나씩을 한쌍으로 묶는 경우 31111, 3211, 322
다시 2와 1 하나씩을 한씽으로 묶는 경우 331
4는 1111
1 두개 더하는 경우 211, 22
2와 1 한쌍 묶는 경우 31
이런 과정으로 다음과 같이 이해할 수 있을 것 같다.
처음 입력받은 수를 1의 합으로 다 seperate 해준다.
그 상태에서 1을 2개씩 묶는 경우를 생각해준다.
1을 2개씩 묶은 후에는 2와 1을 묶는 경우를 생각해준다. 2와 1이 없을때까지...
각각의 경우를 2차원배열로 저장하고, 마지막에 2차원배열의 요소 수(경우 개수)를 출력해준다.

를 좀 더 dp화 시켜보자!
n
1은 1
2는 11
3은 111
4는 1111
5는 11111
이다.
5를 뜯어보자. (5-2)를 1로 표현하면 111이다. 여기에 2를 더하면 (5-2)+2 = 5이고 이를 표현하면 1112 가 된다.
이 말인즉슨, 1, 2의 합으로 정수 n을 나타내려면 (n-2)를 1의 합만으로 나타낸 방법에 2를 더해주면 된다.
더 나아가서, 1, 2, 3의 합으로 정수 n을 나타내려면 (n-3)을 1과 2의 합만으로 나타낸 방법에 3을 더해주면 된다.

예를 들어 N이 4라면 1, 2, 3으로 구할 수 있는 경우는 다음과 같다. 
1의 경우 모두 1가지이다. 
2의 경우 1의 경우의 수 + 앞에서 구한 경우의 수가 누적된다. 
3의 경우도 2의 경우의 수를 구한 후에 앞의 경우의 수를 누적하여 구할 수 있다.
사용하는 수가 2이고 구하는 수가 2인 경우
1로 구할 수 있는 경우의 수는 1이다.
이로 구할 수 있는 경우의 수는 1이다. 따라서 2가 된다.
사용하는 수가 2이고 구하는 수가 4인 경우
앞서 구한 2를 구할 수 있는 경우의 수는 2이고, 1로 구할 수 있는 경우는 1이므로 3이 된다.
 

따라서 2의 경우 `dp[i] += dp[i - 2]`와 같은 점화식을 세울 수 있고, 3의 경우 `dp[i] += dp[i - 3]`과 같은 점화식을 세울 수 있다.

dp = [1] * 10001  

for i in range(2, 10001):
  dp[i] += dp[i - 2]

for i in range(3, 10001): 
  dp[i] += dp[i - 3]

t = int(input())

for _ in range(t):
  n = int(input())
  print(dp[n])
