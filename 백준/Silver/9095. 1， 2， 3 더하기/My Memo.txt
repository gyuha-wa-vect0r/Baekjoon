n = 1 : 1 -> 1개
n = 2 : 1+1 2 -> 2개
n = 3 : 1+1+1 2+1 1+2 3 -> 4개
n = 4 : 1+1+1+1 2+1+1 1+2+1 1+1+2 2+2 3+1 1+3 -> 7개
n = 5 : 1+1+1+1+1 2+1+1+1 1+2+1+1 1+1+2+1 1+1+1+2 3+1+1 1+3+1 1+1+3 2+2+1 2+1+2 1+2+2 3+2 2+3 -> 13개
n = 4인 경우 7은 n = 1인 경우 1, n = 2인 경우 2, n = 3인 경우 4의 합과 같다.
n = 5인 경우 13도 n = 2인 경우 2, n = 3인 경우 4, n = 4인 경우 7의 합과 같다.
위에서 알 수 있듯이 n을 1, 2, 3의 합으로 나타내는 경우의 수는 n-3인 경우 + n-2인 경우 + n-1인 경우와 같다.
이를 점화식으로 표현해보면 d[n] = d[n-1] + d[n-2] + d[n-3] 이다. 단 n은 4 이상부터 적용이 된다.
따라서 n이 1~3인건 따로 넣어주면 될 듯 하다.
이런 내용을 바탕으로 코드의 절차를 생각해보면, 
n이 1~3까지는 경우의 수 저장 배열 d에 수동으로 넣어주고, 반복문을 이용하여 4부터 입력받은 n까지 점화식을 계산하면 될 듯 하다.

dp의 완전 기본격인 문제 느낌이다. 점화식을 찾았고 이를 반복문으로 적용시켰다.
Dynamic Programming은 하나의 큰 문제를 '여러 개의 작은 문제로 나누어서 그 결과를 저장'하여 
다시 큰 문제를 해결할 때 사용하는 것으로 특정한 알고리즘이 아닌 하나의 문제해결 패러다임이라 생각해야 한다.
요약 하자면 큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용한다는 것이다.

-------------------------------------------------------------------------------------------------

(dp 내용 참조 : https://hongjw1938.tistory.com/47)
dp를 적용하려면
1) Overlapping Subproblems(겹치는 부분 문제)
-> DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 
   그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능하다.
   즉, DP는 부분 문제의 결과를 저장하여 재 계산하지 않을 수 있어야 하는데, 
   해당 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다.
2) Optimal Substructure(최적 부분 구조)
-> 부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우를 의미한다. 
   그래서 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일하다!
   만약, A - B까지의 가장 짧은 경로를 찾고자 하는 경우를 예시로 할 때, 
   중간에 X가 있을 때, A - X / X - B가 많은 경로 중 가장 짧은 경로라면 전체 최적 경로도 A - X - B가 정답이 된다.
를 고려해야 한다.

일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다.
1) DP로 풀 수 있는 문제인지 확인한다.
2) 문제의 변수 파악
3) 변수 간 관계식 만들기(점화식)
4) 메모하기(memoization or tabulation)
5) 기저 상태 파악하기
6) 구현하기

① DP로 풀 수 있는 문제인지 확인
애초에 이 부분 부터 해결이 매우 어렵다. 
우선 DP의 조건 부분에서 써내렸듯이, 현재 직면한 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지를 판단해야 한다.
즉, 위에서 쓴 조건들이 충족되는 문제인지를 한 번 체크해보는 것이 좋다.
보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 
DP로 풀 수 있는 경우가 많다.

② 문제의 변수 파악
DP는 현재 변수에 따라 그 결과 값을 찾고 그것을 전달하여 재사용하는 것을 거친다.  
즉, 문제 내 변수의 개수를 알아내야 한다는 것. 이것을 영어로 "state"를 결정한다고 한다.
예를 들어, 피보나치 수열에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 
그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다.
또한, 문자열 간의 차이를 구할 때는 문자열의 길이, Edit 거리 등 2가지 변수를 사용한다. 해당 문제를 몰라도 된다.
또, 유명한 Knapsack 문제에서는 index, 무게로 2가지의 변수를 사용한다. 
이와 같이 해당 문제에서 어떤 변수가 있는지를 파악해야 그에 따른 답을 구할 수 있다.

③ 변수 간 관계식 만들기
변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 
또한 우리는 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다.
그러한 식을 점화식이라고 부르며 그를 통해 우리면 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.
예를 들어 피보나치 수열에서는 f(n) = f(n-1) + f(n-2) 였다. 이는 변수의 개수, 문제의 상황마다 모두 다를 수 있다.

④ 메모하기
변수 간 관계식까지 정상적으로 생성되었다면 변수의 값에 따른 결과를 저장해야 한다. 
이것을 메모한다고 하여 Memoization이라고 부른다.
변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 
그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.
이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.

⑤ 기저 상태 파악하기
여기까지 진행했으면, 가장 작은 문제의 상태를 알아야 한다. 
보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다. 
피보나치 수열을 예시로 들면, f(0) = 0, f(1) = 1과 같은 방식이다. 
이후 두 가지 숫자를 더해가며 값을 구하지만 가장 작은 문제는 저 2개로 볼 수 있다.
해당 기저 문제에 대해 파악 후 미리 배열 등에 저장해두면 된다. 
이 경우, 피보나치 수열은 매우 간단했지만 문제에 따라 좀 복잡할 수 있다.

⑥ 구현하기
개념과 DP를 사용하는 조건, DP 문제를 해결하는 과정도 익혔으니 실제로 어떻게 사용할 수 있는지를 알아보고자 한다. 
DP는 2가지 방식으로 구현할 수 있다.
1) Bottom-Up (Tabulation 방식) - 반복문 사용
-> 아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식이다.
   메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, 
   dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. 
   Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.
2) Top-Down (Memoization 방식) - 재귀 사용
-> dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 위에서 부터 바로 호출을 시작하여 
   dp[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식이다.



